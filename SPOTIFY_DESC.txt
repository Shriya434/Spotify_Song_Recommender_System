
Project Title: Spotify Music Recommender System

---

Tools & Technologies Used:

* Python
* Streamlit â€“ to build the interactive web app
* Pandas â€“ for data manipulation
* NumPy â€“ for numerical operations
* Scikit-learn â€“ for machine learning (StandardScaler, Nearest Neighbors)

---

Project Brief Objective:

To recommend similar songs based on an input song name and artist, using audio features such as danceability, energy, valence, etc., from a Spotify dataset.

---

Explained Code Structure:

---

1.Importing Libraries

(python)
import streamlit as st
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import NearestNeighbors

These libraries help with:

* Building the UI (`streamlit`)
* Data handling (`pandas`, `numpy`)
* Preprocessing and recommendation model (`sklearn`)

2.Loading and Preprocessing Dataset

@st.cache_data

def load_data():
    df = pd.read_csv("spotify dataset.csv")
    df.dropna(subset=['track_name', 'track_artist'], inplace=True)
    df['track_album_release_date'] = pd.to_datetime(df['track_album_release_date'], errors='coerce')
    df['track_album_release_date'] = df['track_album_release_date'].fillna(df['track_album_release_date'].median())
    return df


* `@st.cache_data`: Caches data to speed up loading.

* Loads the Spotify dataset.

* Removes missing `track_name` or `track_artist`.

* Converts album release date to `datetime`.

* Fills missing dates with median to maintain consistency.

3.Model Setup with Nearest Neighbors

def setup_model(df):
    features = ['danceability', 'energy', 'speechiness', 'acousticness',
                'instrumentalness', 'liveness', 'valence', 'tempo']

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(df[features])
//fit:	Learns the parameters (e.g., mean and std in StandardScaler) from the training data.
//transform: Applies the learned transformation to the data.
//fit_transform: Combines fit() and transform() in one step(learns from the data and transforms it).

    model = NearestNeighbors(n_neighbors=6, algorithm='auto')

    model.fit(X_scaled)
    return model, X_scaled, features


* Selects important audio features.
* Scales features using `StandardScaler` for uniformity.
* Trains a K-Nearest Neighbors model with 6 neighbors (1 is the song itself + 5 recommendations).
* Returns the trained model and scaled data.


4.Recommendation Logic


def recommend_songs(df, model, X_scaled, features, track_name, artist_name):
    idx = df[(df['track_name'].str.lower() == track_name.lower()) &
             (df['track_artist'].str.lower() == artist_name.lower())].index
    if len(idx) == 0:
        return None
    distances, indices = model.kneighbors([X_scaled[idx[0]]])
    return df.iloc[indices[0][1:]][['track_name', 'track_artist', 'playlist_genre']]


* Finds the songâ€™s index using name and artist.
* Uses `kneighbors()` to find similar songs.
* Skips the first one (which is the input song itself).
* Returns the top 5 similar songs with name, artist, and genre.

5.Streamlit UI Logic

st.title("ðŸŽ§ Spotify Music Recommender System")


Displays app title on the webpage.

df = load_data()
model, X_scaled, features = setup_model(df)


//Loads and prepares the data and model.


track_input = st.text_input("Enter a track name:")
artist_input = st.text_input("Enter the artist name:")


//Takes user input for the song and artist.


if st.button("Get Recommendations"):
    if not track_input or not artist_input:
        st.warning("Please enter both track name and artist name.")
    else:
        results = recommend_songs(df, model, X_scaled, features, track_input, artist_input)
        if results is not None:
            st.subheader("Recommended Songs:")
            st.dataframe(results)
        else:
            st.error("Track not found. Please check spelling or try another song.")


* On button click, it checks inputs.
* Calls `recommend_songs()` to get recommendations.
* Displays recommendations in a table.
* If song not found, shows an error.

How It Works Internally

1. User inputs a known song and artist.
2. System locates that song in the dataset.
3. Extracts its features and compares with others using **KNN**.
4. Finds **most similar songs** based on feature distance.
5. Returns the top 5 similar ones.

Highlights :

1. Problem Solving : used ML to solve a real-world problem (song recommendation).
2. Data Preprocessing : How you handled missing data and used normalization.
3. ML Model : You used unsupervised learning (KNN) for similarity detection.
4. Frontend with Streamlit : Interactive UI for better user experience.
5. Optimization : Use of `@st.cache_data` for faster performance.

Future Improvements 

* Add audio previews using Spotify API.
* Accept partial song names using fuzzy matching.
* Include more features like popularity or user preferences.
* Add a dropdown for genre-based recommendations.


